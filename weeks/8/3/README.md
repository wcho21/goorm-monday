# 직사각형 만들기

![Difficulty Hard](https://img.shields.io/badge/Difficulty-Hard-red)

8주차 세 번째 문제 [직사각형 만들기][problem].

[problem]: https://edu.goorm.io/learn/lecture/33428/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%A8%BC%EB%8D%B0%EC%9D%B4-%EC%B1%8C%EB%A6%B0%EC%A7%80-%EC%8B%9C%EC%A6%8C1/lesson/1686053/8%EC%A3%BC%EC%B0%A8-%EB%AC%B8%EC%A0%9C-3-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95-%EB%A7%8C%EB%93%A4%EA%B8%B0



## 문제 요약

여러 막대기의 길이가 주어진다.

같은 길이의 두 막대기가 한 쌍 있으면, 그 네 막대기로 사각형을 만들 수 있다.

그렇게 만든 사각형들의 넓이를 더했을 때 나올 수 있는 최댓값을 구해야 한다.



## 발상

다음 과정을 반복하여 답을 구한다.

먼저, 가장 긴 두 막대기를 찾는다.
옆 자리가 비어있으면, 그 두 막대기를 잠시 둔다.
그렇지 않으면, 그것과 사각형을 만들어 넓이를 구하고, 그 네 막대기를 버린다.

예를 들어, 여덟 막대기의 길이가 다음과 같이 주어졌다고 하자.

```
4 4 4 4 2 2 1 1
```

그러면 앞의 두 쌍 `4 4 4 4`와, 뒤의 두 쌍 `2 2 1 1`로 사각형을 만든다.
그리고 그 사각형의 넓이를 더하면 답이 된다.

사각형을 만들 때, 네 막대기의 길이가 꼭 다를 필요가 없다는 사실을 참고하자. (여기선 `4 4 4 4`가 이에 해당한다.)

왜 큰 막대기부터 선택하면 넓이의 합이 최대가 되는 지는 [별도의 문서][proof]에서 증명한다.

[proof]: ./PROOF.md



### Follow-up: 더 빠른 방법 찾기

같은 길이의 막대기가 많이 주어진다고 생각해보자.
예를 들어, 다음 여덟 막대기가 있다.

```
4 4 4 4 4 4 4 4
```

옆에 둔 막대기가 없는 한, 같은 길이의 막대기를 네 개씩 쥐어 더 빨리 사각형을 만들 수 있다.
여기서는 길이가 같은 막대기가 여덟개 있으므로, `8/4`, 즉 `2` 개의 정사각형을 만들 수 있다.

그러면 이 개선이 시간 복잡도에 영향을 주는가?

그렇지 않다.
최악의 경우, 즉 서로 다른 길이의 막대기가 주어질 경우, 네 개씩 쥘 수 없기 때문에 기존 방법과 다르지 않다.

그리고 뒤에서 보겠지만, 모든 가능한 길이 $L$에 대해 탐색할 것이다.
따라서 최선의 경우, 즉 모든 막대기가 같은 길이일 경우에도 $O(L)$에서 개선은 없다.


### 주의 사항

이 문제의 답은 매우 큰 수로 나올 수 있다.
(예를 들어, 최대 길이의 막대기만 최대 개수로 주어지는 경우가 그렇다.)

그런데 문제에서 따로 나머지 연산을 요구하지 않으므로, 큰 자료형을 쓰는 등으로 오버플로우에 대비하자.



## 코드 설명

막대기의 길이에 대해 개수를 카운트한다.

큰 길이부터 개수를 확인한다.
옆에 둔 막대기가 있다면, 먼저 그것과 사각형을 만든다. (이제 옆에 둔 막대기는 없다.)
그리고 (가능하다면) 막대기 네 개씩 쥐어 정사각형을 만든다.
만약 막대기 두 개 이상 남으면, 옆에 둔다.
이 과정을 반복한다.

```python
# lengthCounts: 각 길이마다 막대기 개수가 담긴 배열
# aside: 옆에 둔 막대기의 길이 (EMPTY는 비어있음을 나타내는 값)

for length, numSticks in reversed(list(enumerate(lengthCounts))):
    # 두 개 미만이면 볼 필요 없음
    if numSticks < 2:
        continue

    # 옆에 둔 막대기가 있으면 먼저 직사각형 만들기
    if aside != EMPTY:
        rectangleArea = length * aside
        areaSum += rectangleArea

        aside = EMPTY
        numSticks -= 2

    # 정사각형 만들기
    if numSticks >= 4:
        numSquares = numSticks // 4
        squareArea = length * length
        areaSum += squareArea * numSquares

        numSticks -= numSquares * 4

    # 남는 막대기 옆에 두기
    if numSticks >= 2:
        numSticks -= 2

        aside = length

print(areaSum)
```



## 복잡도

막대기의 개수를 $N$, 막대기의 최대 길이를 $L$ 이라고 하자.



### 시간

먼저, $N$ 개의 막대기가 입력되므로, 입력 처리는 $O(N)$이 소요된다.

그리고 `for` 문은 가능한 모든 길이를 탐색하므로 $O(L)$이 소요된다.

따라서 $O(N+L)$.



### 공간

가능한 모든 길이를 담은 배열로 인해 $O(L)$.



### Follow-up: 막대기의 길이가 길 때

이 문제는 $L$이 충분히 작았다.

만약 $L$이 막대기의 개수 $N$보다 상대적으로 크다면, 복잡도를 $N$에 의존하도록 수정할 수 있다.

이미 $O(N)$이 소요되는 입력 처리를 보자.

기존 $O(L)$의 배열 대신, 길이가 키이고 개수가 값인 해시 테이블을 사용한다.
그리고 기존 코드의 `for` 문이 이 해시 테이블의 엔트리를 탐색하도록 바꾼다.

그러면 그 `for` 문은 $O(N)$의 시간이 소요되므로, 시간 복잡도는 $O(N)$이 된다.
공간 복잡도는 해시 테이블로 인해 역시 $O(N)$이다.
