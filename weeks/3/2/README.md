# 폴더 폰 자판

![Difficulty Easy](https://img.shields.io/badge/Difficulty-Easy-green)

3주차 두 번째 문제 [폴더 폰 자판][problem].

[problem]: https://edu.goorm.io/learn/lecture/33428/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%A8%BC%EB%8D%B0%EC%9D%B4-%EC%B1%8C%EB%A6%B0%EC%A7%80-%EC%8B%9C%EC%A6%8C1/lesson/1672665/3%EC%A3%BC%EC%B0%A8-%EB%AC%B8%EC%A0%9C-2-%ED%8F%B4%EB%8D%94-%ED%8F%B0-%EC%9E%90%ED%8C%90



## 문제

10년 전, 구름이가 처음으로 구매했던 휴대폰은 폴더 폰이다.
이 폴더 폰의 자판은 최근의 휴대폰의 입력 방식과는 차이가 있다.
구름이가 사용했던 폴더 폰의 자판은 아래 그림과 같다.

```
 1    2    3
.,?! ABC  DEF
 4    5    6
GHI  JKL  MNO
 7    8    9
PQRS TUV  WXYZ
```

자판은 $9$개의 버튼으로 이루어져 있다.
이 자판을 이용해서 문자를 입력하는 방법은 아래와 같다.

- 버튼을 한 번 누르면 그 버튼에 해당하는 숫자를 입력할 수 있다.
- 버튼을 $k$번 누르면 그 버튼의 $k-1$번째에 해당하는 문자를 입력할 수 있다.
    예를 들어 5번 버튼을 두 번 누르면 `J`가 입력된다.
- 만약 그 버튼에 적혀있는 숫자와 문자의 개수보다 더 많이 버튼을 누르면, 다시 숫자, 첫 번째 문자, 두 번째 문자... 순서로 입력되는 문자가 반복된다.
    예를 들어 6번 버튼을 다섯 번 누르면 `6`이 입력되고, 여섯 번 누르면 `M`이 입력된다.

구름이가 폴더 폰의 숫자 버튼을 누른 순서가 주어진다.
이 순서를 보고, 구름이가 원래 입력하려고 했던 문장을 유추해보자.
조건을 만족하는 문장이 여러 가지라면 그 중 가장 짧은 문장을 출력한다.
이러한 문장은 항상 유일하다는 것을 증명할 수 있다.

### 입력

첫째 줄에 구름이가 버튼을 누른 횟수 $N$이 주어진다.
둘째 줄에 구름이가 버튼을 누른 순서를 나타내는 문자열 $S$가 주어진다.

- $1 \leq N \leq 10^5$
- $S$는 `1`과 `9` 사이의 숫자로만 구성되어 있다.

### 출력

구름이가 버튼을 누른 순서를 바탕으로, 구름이가 실제로 입력하려고 했던 문장을 출력한다.
가능한 문장이 여러 개라면 그 중 길이가 가장 짧은 문장을 출력한다.



## 발상

단순히 문제에서 주어진 대로 구현하면 된다.

연속으로 입력된 키가 있다면, 어떤 키가 몇번 연속으로 입력됐는지 구한다.
이것을 가지고 숫자 키에서 어떤 문자가 입력되는지 구한다.



## 코드 설명

연속으로 입력된 키를 구분하는 것은 현재 입력된 키와 다음 입력된 키가 다른지 구분하면 된다.

연속 입력이 끝났을 때, 입력된 키와 횟수를 가지고 문자를 구한다.

다만 키가 가진 문자보다 더 많이 누를 때, 다시 첫 문자로 되돌아오므로, 나머지 연산으로 입력된 문자를 구한다.
예를 들어 키가 입력할 수 있는 문자가 문자열 `"ABC"`로 주어질 때, 5번째 문자는 `5 % 3`, 즉 두 번째 문자로 본다.

```python
pads = [ "", "1.,?!", "2ABC", "3DEF", "4GHI", "5JKL", "6MNO", "7PQRS", "8TUV", "9WXYZ" ]

# 입력 키와 횟수로 입력 문자를 구하는 함수
def getCharFromPresses(key, presses):
    # 숫자로 변환
    keyNum = ord(key) - ord('0')

    # 키 패드의 문자 인덱스 구하기
    mod = len(pads[keyNum])
    keyIndex = (presses-1) % mod

    return pads[keyNum][keyIndex]

numPresses = int(readline())
presses = readline()

curChar = presses[0]
streak = 1
for i in range(numPresses):
    if presses[i] == presses[i+1]:
        streak += 1
        continue

    # 현재 문자와 다음 것과 다를 때 입력할 문자를 구함
    print(getCharFromPresses(curChar, streak), end="")

    # 현재 문자와 입력 횟수 초기화
    streak = 1
    curChar = presses[i+1]

print("")
```



## 복잡도

입력 키가 $N$ 개 주어진다고 하자.



### 시간

`for` 반복문은 각 입력키에 대해 반복하고, 그 때마다 $O(1)$ 의 연산을 수행하므로, $O(N)$.




### 공간

입력 키를 담는 배열로 인해 $O(N)$.
