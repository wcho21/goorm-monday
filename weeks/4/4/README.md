# 주차 구역 나누기

![Difficulty Hard](https://img.shields.io/badge/Difficulty-Hard-red)

4주차 네 번째 문제 [주차 구역 나누기][problem].

[problem]: https://edu.goorm.io/learn/lecture/33428/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%A8%BC%EB%8D%B0%EC%9D%B4-%EC%B1%8C%EB%A6%B0%EC%A7%80-%EC%8B%9C%EC%A6%8C1/lesson/1679181/4%EC%A3%BC%EC%B0%A8-%EB%AC%B8%EC%A0%9C-4-%EC%A3%BC%EC%B0%A8-%EA%B5%AC%EC%97%AD-%EB%82%98%EB%88%84%EA%B8%B0



## 문제

구름이는 주차 구역을 나누고 있다.
보통 주차 구역을 나눌 때는 한 가지 색상의 선을 그어서 영역을 구분하지만, 예술가인 구름이는 주차 구역을 여러 가지 색으로 색칠하는 방법으로 구역을 나누기로 한다.

주차장은 세로 길이가 $1$, 가로 길이가 $2N$ 크기의 공간이다.
구름이는 이 공간을 $1 \times 1$ 크기의 구역 $2N$개로 나눈 뒤, 각 구역에 색을 칠해서 영역을 구분하고자 한다.
이 작업을 위해 구름이는 $N$가지 색의 페인트를 각각 $2$개씩 주문했고, 아래 규칙에 따라 각 구역을 칠할 것이다.

- $1$개의 페인트는 $1 \times 1$ 크기의 구역 하나를 색칠하는 데만 사용한다.
    페인트의 양은 항상 해당 구역을 다 칠하기에 충분하다.
- 양옆으로 인접한 주차 구역은 서로 다른 색으로 칠한다.
- 같은 색으로 칠해진 두 구역은 같은 구역으로 나눠진 것으로 본다.
- 색의 배치가 다르더라도, 나눠진 주차 구역이 모두 동일하다면 같은 방식으로 나눠진 것으로 본다.

이때 주차 구역을 나눌 수 있는 모든 경우의 수를 구하시오.
단, 경우의 수가 너무 커질 수 있으니 $100 \thinspace 000 \thinspace 007$ 이를 로 나눈 나머지를 출력한다.

### 입력

첫째 줄에 정수 $N$이 주어진다.

- $2 \leq N \leq 100 \thinspace 000$

### 출력

주차 구역을 나눌 수 있는 모든 경우의 수를 $100 \thinspace 000 \thinspace 007$$로 나눈 나머지를 출력하시오.



## 발상

Bottom-up [DP][dp]로 해결한다.

[dp]: https://en.wikipedia.org/wiki/Dynamic_programming

$N < k$ 인 경우 해결되었다고 치고, $N = k$ 인 경우를 해결하자.
즉 $k-1$ 가지 색상이 사용된 주차 구역에, $k$ 번째 새로운 색상의 두 칸을 추가한다.

그러면 크게 두 가지 경우로 나눌 수 있다.
이미 잘 나뉘어진 주차 구역에 추가하는 경우와, 같은 색상이 두 칸 인접해있어서 잘못 나뉜 주차 구역에 추가하는 경우이다.



### 기존 주차 구역에서 추가하는 경우

예를 들어 3가지 색상 A, B, C로 나뉜 주차 구역에 네 번째 색상 D를 추가한다고 하자.
한 칸을 맨 왼쪽에 추가하면, 다른 한 칸은 6자리에 끼워넣을 수 있다.

```
D A B C A B C
   ^ ^ ^ ^ ^ ^ <- D
```

색상 배치가 같으면 동일한 경우로 보기 때문에, 이것이 전부이다.

일반화하면, $k$ 번째 색상은 $2k-2$ 개의 자리가 생긴다.



### 잘못 나뉜 주차 구역에서 추가하는 경우

예를 들어 3가지 색상 A, B, C로 잘못 나뉘었다고 하자.
그러면 네 번째 색상 D를 아래처럼 끼워넣어 주차 구역을 올바르게 나눌 수 있다.

```
 A B C C A B
^     ^
D     D
```

이처럼 잘못 나뉜 주차 구역마다 한 가지 경우가 새로 추가된다.
(여기서 잘못 나뉜 주차 구역은 두 칸만 같은 색상으로 인접해야 한다. 새로운 색상 한칸은 항상 맨 왼쪽에 둘 것이기 때문에, 더 많은 칸이 인접하면 해결할 수 없다.)



### 총 경우의 수

$a_n$를 $n$ 개의 색으로 올바르게 나뉜 주차 구역의 개수라고 하자.

위에서 본 것처럼, $k$ 개의 색으로 올바르게 나뉜 주차 구역은 $(2k-2) a_{k-1}$ 개 존재한다.

그리고 $k-1$ 개의 색으로 잘못 나뉜 주차 구역은 $(2k-3) a_{k-2} + \cdots + 5 a_2 + 3 a_1 + 1 a_0$ 개 존재한다. (곧 이유를 볼 것이다.)

따라서 경우의 수 $a_k$은 이 둘을 더한 것과 같다.

$$
a_k = (2k-2) a_{k-1} + (2k-3) a_{k-2} + \cdots + 5 a_2 + 3 a_1 + 1 a_0
$$



### 잘못 나뉘는 경우 세기

잘못 나눌 수 있는 방법은 여러가지이다.

다음과 같이 한 쌍, 두 쌍, 세 쌍 등으로 중첩되어 잘못 나뉠 수 있다. 이를 각각 랭크 1, 2, 3 이라고 부르자.

```
A A (rank 1)
A B B A (rank 2)
A B C C B A (rank 3)
```

(이처럼 $n$ 쌍으로 잘못 나뉜 경우를 랭크 $n$이라고 부르자.)

이를 이용해 잘못 나뉜 경우를 분류할 수 있다.
예를 들어 3개의 색상이 쓰였을 때, 다음과 같다.

#### 2개 색상으로 잘 나뉜 주차 구역에 랭크 1이 끼어들었을 때

아래 처럼 C 색상으로 인접한 두 칸을 끼워넣을 수 있다.
여기서는 다섯 자리가 가능하다.

```
 A B A B
^ ^ ^ ^ ^ <- C C
```

올바르게 나뉜 주차 구역마다 가능하기 때문에, 총 $5 a_2$ 개 만큼 가능하다.

#### 1개 색상으로 잘 나뉜 주차 구역에 랭크 2가 끼어들었을 때

1개 색상으로 잘 나뉜 주차 구역은 존재할 수 없다.
따라서 불가능하다.

하지만 $a_1 = 0$이라고 두면, $3 a_1 (=0)$ 개 만큼 있다고 쓸 순 있을 것이다.

#### 0개 색상으로 잘 나뉜 주차 구역에 랭크 3이 끼어들었을 때

0개 색상으로 나눈다는게 겉보기에는 이상하지만, 주차 구역이 아무 것도 없는 경우로 생각하자.
그러면 다음과 같이 한 자리가 가능하다.

```
 (Empty)
^
A B C C B A
```

$a_0 = 1$로 두자. 그러면 $1 a_0 (=1)$ 개 만큼 있다고 쓸 수 있다.

#### 종합하기

총 $5 a_2 + 3 a_1 + 1 a_0$개가 존재한다.

이런 식으로 관찰해보면 $k-1$ 개의 색상으로 잘못 나눌 수 있는 경우의 수를 구할 수 있다.
(즉 $(2k-3) a_{k-2} + \cdots + 5 a_2 + 3 a_1 + 1 a_0$ 개)



### 문제 해결하기

결과적으로, 색상이 $k$ 가지 일 때, 주차 구역의 개수는 다음과 같다.

$$
a_k = (2k-2) a_{k-1} + (2k-3) a_{k-2} + \cdots + 5 a_2 + 3 a_1 + 1 a_0
$$

DP 테이블을 색상의 개수에 대해 만든다고 해보자.
그러면 이전 단계로부터 $a_k$를 계산할 수 있어야 한다.
$a_k - a_{k-1}$를 계산해보자.

$$
\begin{aligned}
  \begin{alignedat}{1}
    a_k = \thinspace && (2k-2) a_{k-1} + (2k-3) a_{k-2} + (2k-4) a_{k-3} + \cdots + 5 a_2 + 3 a_1 + 1 a_0 \\
    a_{k-1} = \thinspace && (2k-4) a_{k-2} + (2k-4) a_{k-3} + \cdots + 5 a_2 + 3 a_1 + 1 a_0
  \end{alignedat}
\end{aligned}
$$

그러면 $a_k = (2k-2) a_{k-1} + a_{k-2}$을 얻는다.
즉 두 이전 단계로부터 다음 단계를 계산할 수 있다.

그런데 위에서 보았듯 $a_1 = 0$, $a_0 = 1$으로 정해져 있으므로, 어떤 $k$에 대해서든 구할 수 있게 된다.



## 코드 설명

이 문제는 단순히 DP 테이블을 완성하면 되기 때문에, 다음 `for` 문으로 해결할 수 있다.

```python
# numColors: 총 색상 개수
# dp: DP 테이블, 각 색상 개수에 대한 주차 구역의 개수
dp[2] = 1

for i in range(3, numColors+1):
    dp[i] = ((2*i - 1) * dp[i-1] + dp[i-2]) % MOD

print(dp[numColors])
```



## 복잡도

총 색상의 개수를 $N$ 이라고 하자.



### 시간

DP 테이블을 완성하기 위한 `for` 문은 $O(N)$ 만큼 반복한다.
따라서 $O(N)$.



### 공간

DP 테이블로 인하여 $O(N)$.
