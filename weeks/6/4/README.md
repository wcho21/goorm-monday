# 경쟁 배타의 원리

![Difficulty Medium](https://img.shields.io/badge/Difficulty-Medium-yellow)

6주차 네 번째 문제 [경쟁 배타의 원리][problem].

[problem]: https://edu.goorm.io/learn/lecture/33428/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%A8%BC%EB%8D%B0%EC%9D%B4-%EC%B1%8C%EB%A6%B0%EC%A7%80-%EC%8B%9C%EC%A6%8C1/lesson/1682315/6%EC%A3%BC%EC%B0%A8-%EB%AC%B8%EC%A0%9C-4-%EA%B2%BD%EC%9F%81-%EB%B0%B0%ED%83%80%EC%9D%98-%EC%9B%90%EB%A6%AC



## 문제 요약

정사각형의 영역이 주어지고, 각 생물의 종마다 그 안에 직사각형의 **서식 영역**이 주어진다.

이 **서식 영역**은 겹칠 수 있다.

정확히 K 개의 종이 겹치는 영역의 넓이를 구해야 한다.



## 발상

한 변이 $L$인 정사각형에 총 $N$개의 종이 서식한다고 하자.

이차원 배열을 만들고, 각 칸마다 서식하는 종을 마주칠 때마다 카운트할 수도 있지만, 타임 아웃이다.

각 서식 영역은 넓이가 $O(L^2)$이기 때문에, 이 방법은 총 $O(NL^2)$의 시간 복잡도를 가진다.
문제에서는 $L=1000$, $N \leq 100000$ 이기 때문에, 적어도 1000억 번의 연산이 필요하다.
예를 들어, C++ 코드에서 1억번의 연산이 1초가 걸린다고 하면 시간 내에 수행할 수 없다.

각 칸마다 종의 개수를 카운트하는 대신, 직사각형 영역의 꼭짓점만 이용해 서식 영역을 인코딩할 수 있다.
그러면 각 종 마다 서식 영역의 기록은 $O(L^2)$ 대신 $O(1)$ 에 수행할 수 있게 된다.

그 인코딩은 좌상단에 우하단에 `1`, 나머지 두 곳에 `-1`을 기록한다.
모든 종에 대해 서식 영역을 기록한 뒤, [프리픽스 섬][prefix-sum]으로 각 칸마다 서식하는 종의 개수를 알아낸다.

[prefix-sum]: https://en.wikipedia.org/wiki/Prefix_sum

예를 들어, 두 종의 생물이 각각 $x = [0,3)$, $y = [0,3)$ 영역과 $x = [1,5)$, $y = [1,4)$ 영역에 서식한다고 하자.
그러면 각 칸마다 종의 개수는 이렇게 된다.

```
   0  1  2  3  4  5
0  1  1  1  0  0  0
1  1  2  2  1  1  0
2  1  2  2  1  1  0
3  0  1  1  1  1  0
4  0  0  0  0  0  0
```

그러나 이것 대신 앞서 언급한 방법대로 꼭지점만 이용해 인코딩한다.

```
   0  1  2  3  4  5
0  1  0  0 -1  0  0
1  0  1  0  0  0 -1
2  0  0  0  0  0  0
3 -1  0  0  1  0  0
4  0 -1  0  0  0  1
```

디코딩, 즉 원래의 정보를 복원하기 위해, 각 행마다 프리픽스 섬을 구하고, 그 결과에서 각 열마다 프리픽스 섬을 구한다.

```
[prefix sum for each row]
   0  1  2  3  4  5
0  1  1  1  0  0  0
1  0  1  1  1  1  0
2  0  0  0  0  0  0
3 -1 -1 -1  0  0  0
4  0 -1 -1 -1 -1  0

[prefix sum for each column]
   0  1  2  3  4  5
0  1  1  1  0  0  0
1  1  2  2  1  1  0
2  1  2  2  1  1  0
3  0  1  1  1  1  0
4  0  0  0  0  0  0
```

## 코드 설명

서식 영역을 직사각형의 꼭지점 좌표에 인코딩한 뒤에, 프리픽스 섬으로 각 칸마다 종의 개수를 구한다.
그리고 종의 개수가 관심있는 개수와 일치하는 칸을 센다.

```python
# grid: 서식 공간을 표현하기 위한 2차원 배열
# numSpecies: 생물 종의 개수
# threshold: 세려는 칸의 종의 개수

# 각 종마다 영역의 꼭지점에 서식 영역 인코딩
for _ in range(numSpecies):
    x1, y1, x2, y2 = map(int, readline().split())
    grid[y1][x1] += 1
    grid[y1][x2] -= 1
    grid[y2][x1] -= 1
    grid[y2][x2] += 1

# 행에 대한 프리픽스 섬
for y in range(0, SIDE):
    for x in range(1, SIDE):
        grid[y][x] += grid[y][x-1]

# 열에 대한 프리픽스 섬
for x in range(0, SIDE):
    for y in range(1, SIDE):
        grid[y][x] += grid[y-1][x]

# 종이 threshold 만큼 있는 칸의 개수 세기
count = 0
for y in range(SIDE):
    for x in range(SIDE):
        if grid[y][x] == threshold:
            count += 1

print(count)
```

## 복잡도

정사각형의 한 변이 $L$ 이라고 하자.

### 시간

각 이중 `for` 문은 정사각형의 모든 칸을 방문한다.
그러므로 $O(L^2)$.

### 공간

정사각형을 기록하기 위한 이차원 배열로 인해 $O(L^2)$.
