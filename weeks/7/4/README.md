# 이상한 미로

![Difficulty Hard](https://img.shields.io/badge/Difficulty-Hard-red)

7주차 네 번째 문제 [이상한 미로][problem].

[problem]: https://edu.goorm.io/learn/lecture/33428/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%A8%BC%EB%8D%B0%EC%9D%B4-%EC%B1%8C%EB%A6%B0%EC%A7%80-%EC%8B%9C%EC%A6%8C1/lesson/1684546/7%EC%A3%BC%EC%B0%A8-%EB%AC%B8%EC%A0%9C-4-%EC%9D%B4%EC%83%81%ED%95%9C-%EB%AF%B8%EB%A1%9C



## 문제

구름이는 이상한 미로에 갇혔다.
미로는 $N$개의 방과 $M$개의 복도로 이루어져 있고, 각 방에는 $1$부터 $N$까지의 번호가 붙어 있다.
그리고 각 방의 바닥에는 $1$부터 $10$ 사이의 정수 $A_i$가 쓰여있다.

이 이상한 미로에는 이상한 규칙들이 있다.

- 방에서 움직이는 데 걸리는 시간은 고려하지 않는다.
- 미로에 있는 모든 복도는 양방향으로 이동할 수 있고, 복도마다 지나가는 데 걸리는 시간이 정해져 있다.
- $i$번 방과 $j$번 방이 복도로 직접 연결되어 있고, $j$번 방과 $k$번 방이 복도로 직접 연결되어 있을 때, 두 복도를 이용해 $i$번 방에서 $k$번 방으로 이동하려면 $i$를 $A_j$로 나눈 나머지와 $k$를 $A_j$로 나눈 나머지가 같아야 한다.

구름이는 현재 $1$번 방에 있고, 탈출구는 $N$번 방에 있다.
구름이가 이 이상한 미로에서 탈출할 수 있는지, 탈출할 수 있다면 구름이가 탈출하기까지 최소 얼마나 시간이 걸리는지 구해보자.
단, 맨 처음에 이용하는 복도는 위의 조건과는 상관 없이 원하는 복도를 이용할 수 있다.

### 입력

첫째 줄에는 이상한 미로에 있는 방의 개수 $N$과 복도의 개수 $M$이 공백을 두고 주어진다.

둘째 줄에는 $A_1, \dots, A_N$이 공백을 두고 주어진다.

다음 개의 $M$줄에는 복도의 정보를 의미하는 $u, v, w$가 공백을 두고 주어진다.
복도는 $u$번 방과 $v$번 방 사이를 잇고 있으며, 복도를 지나는 데 걸리는 시간이 $w$라는 의미이다.

- $3 \leq N \leq 100 \thinspace 000$
- $0 \leq M \leq 200 \thinspace 000$
- $1 \leq A_i \leq 10$
- $1 \leq u, v \leq N$
- $1 \leq w \leq 10^9$
- 입력에서 주어지는 모든 수는 정수이다.

### 출력

구름이가 어떤 경로를 이용하더라도 $N$번 방에 도달할 수 없다면 `-1`을 출력한다.
그렇지 않다면 $N$번 방에 도달하는 데 필요한 최소 시간을 출력한다.



## 발상

어떤 복도든 항상 지날 수 있다고 해보자.
그러면 단순히 최소 시간이 걸리는 경로를 찾는 문제가 된다.
그리고 복도를 지나는 데 걸리는 시간은 음수가 아니기 때문에, [다익스트라 알고리즘][dijkstra]으로 풀 수 있다.

[dijkstra]: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm

한편 원래의 문제는 아무 복도나 지날 수 없다.
그러면 지날 수 없을 때마다 그 복도를 없는 것으로 취급하자.
그러면 여전히 다익스트라 알고리즘으로 해결할 수 있는 문제로 남는다.

### 최소 시간 테이블의 문제

다익스트라 알고리즘의 구현을 위해, 각 방마다 최소 시간을 기록해놓자.
그런데 그 최소 시간은 이전에 방문했던 방마다 다르게 기록할 필요가 있다.

예를 들어 미로가 이렇게 있다고 해보자.

```
        (1)       (1)          (1)
1 [1] ----- 2 [1] ----- 4 [2] ----- 5 [1]
       |             |
       `--- 3 [1] ---'
        (2)       (1)
```

`N`은 방 번호, `[N]`은 바닥의 숫자, `(N)`은 복도를 지나는 데 필요한 시간이다.

1번 방은 다음 어느 방이든 방문할 수 있다.
그러면 이 테이블과 우선순위 큐는 이렇게 된다.

```
[Table]
  1   2   3   4   5
--- --- --- --- ---
  0   1   2

[Queue]
2, 3
```

2번 방을 방문하면, 4번 방을 방문할 수 있다.
하지만 5번 방은 방문할 수 없게 된다. (방 번호 2와 5는 바닥 숫자 2로 나눈 나머지가 다르기 때문이다.)
이 사실을 알 게 될 때, 테이블과 우선순위 큐는 이렇게 된다.

```
[Table]
  1   2   3   4   5
--- --- --- --- ---
  0   1   2   2

[Queue]
3
```

이후 3번 방을 거치면 5번 방으로 방문할 수 있어야 한다.
하지만 테이블에서 4번 방의 최소 시간은 `2` 이므로, 이미 시간이 그만큼 소요된 3번 방 루트는 4번 방의 방문을 생각하지 않는다.
따라서 올바른 답을 낼 수 없게 된다.

### 이전 방마다 최소 시간 기록하기

최소 시간 테이블을 이전 방마다 작성하면, 이 문제를 해결할 수 있다.

이제 1번 방에서 그 다음 방들을 큐에 넣었을 때, 테이블은 이렇게 된다.

```
[Table]
From\To   1   2   3   4   5
------- --- --- --- --- ---
      1   0   1   2
      2
      3
      4
      5

[Queue]
2, 3
```

2번 방을 거쳐 5번 방으로 갈 수 없다는 것을 알 게 될 때는 이렇게 된다.

```
[Table]
From\To   1   2   3   4   5
------- --- --- --- --- ---
      1   0   1   2
      2               2
      3
      4
      5

[Queue]
3
```

이후, 3번 방에서 4번 방으로 가는 경우가 테이블에 별도의 행으로 있으므로, 마지막에 4라는 올바른 답을 내게 된다.

```
[Table]
From\To   1   2   3   4   5
------- --- --- --- --- ---
      1   0   1   2
      2               2
      3               3
      4                   4
      5
```

### 이전 방에 대해 경우의 수 줄이기

이전 방마다 최소 시간을 기록하려면, 방 개수의 제곱에 해당하는 칸이 필요하다.
그러면 방이 많을 때 주어진 메모리를 초과하게 된다.

그런데 이런 점을 관찰해보자.
어떤 방에서 왔을 때 어떤 복도를 지날 수 없다는걸 알아냈다고 하자.
그러면 다른 방에서 그 복도를 지나려고 할 때, 지날 수 없다는 걸 바로 알 수 있는 경우가 있다.

예를 들어 미로가 이렇게 있다고 하자. (`?`라는 방의 번호는 중요하지 않다.)

```
11 ----- ? [10] --- 12
      |
21 ---|
      |
31 ---'
```

11번 방에서 12번 방으로 간다고 하자.
그러면 11과 12는 10으로 나눈 나머지가 다르므로 갈 수 없다는 것을 알게된다.
그런데 11, 21, 31 전부 10으로 나눈 나머지가 같다.
따라서 나머지 방 또한 12번 방으로 갈 수 없다는 것 또한 함께 알게된다.

한편 다음처럼 지날 수 있는 경우를 생각해보자.

```
11 ----- ? [10] --- 41
      |
21 ---|
      |
31 ---'
```

11, 21, 31 전부 10으로 나눈 나머지가 41과 같다.
따라서 어떤 방에서 오든지 41번 방에 갈 수 있다.
그런데 어느 방에서 오든지, 가장 먼저 41번 방에 도달한 경로가 최소 시간을 가진다.
그러므로 나머지 두 방은 볼 필요가 없게 된다.

이렇게 나머지가 같은 방을 하나의 그룹으로 생각해보자.
그러면 이 그룹은 하나의 방만 확인해보면 된다.
즉 이 그룹의 방에서 출발했을 때 지날 수 없는 복도가 있다면, 그 그룹의 방은 모두 볼 필요가 없다.
또한 지날 수 있는 복도가 있다면, 그것을 알았을 때가 최소 시간 경로이므로, 이 경우에도 그 그룹은 볼 필요가 없다.

정리하면, 이전 방에 대해서 테이블을 작성하는 대신, 이런 나머지 그룹에 대해서 테이블을 작성할 수 있다.
그리고 나머지는 기껏해야 10보다 작다. (방 번호가 최대 10이기 때문이다.)

이를 이용해 테이블을 방 개수의 제곱이라는 크기에서, 방 개수의 열 배라는 크기로 줄일 수 있다.



## 코드 설명

최소 시간 테이블의 모든 칸을 무한대로 초기화 해놓는다.
미로를 그래프로 표현한 다음, 다익스트라 알고리즘으로 최소 시간을 찾는다.
다익스트라 알고리즘은 갈 수 있는 다음 방을 우선순위 큐에 대기시킨다.
이때 이미 같은 나머지 그룹의 다른 방에서 시도 했거나, 나머지가 달라 건널 수 없는 복도라면 스킵한다.

```python
# floorNumbers: 각 방마다 바닥 번호가 담긴 배열
# times: 최소 시간 테이블을 위한 이차원 배열
# passages: 다음 방과 소요 시간이 담긴 배열
# destRoom: 목적지 방 번호

# 목적지 방 destRoom에 도달할 수 있으면 최소시간, 아니면 -1을 리턴
def getTime(destRoom):
    times[1][0] = 0

    queue = []

    # 1번 방의 다음 방을 큐에 대기
    for nextRoom, walkingTime in passages[1]:
        roomMod = 1 % floorNumbers[nextRoom] # 현재 방이 속한 나머지 그룹
        nextTime = walkingTime

        heappush(queue, (nextTime, nextRoom, roomMod))

    while len(queue) > 0:
        time, room, prevMod = heappop(queue)

        # 도달 했다면 시간을 리턴
        if room == destRoom:
            return time

        for nextRoom, walkingTime in passages[room]:
            roomMod = room % floorNumbers[nextRoom] # 현재 방이 속한 나머지 그룹
            nextTime = time + walkingTime

            # 같은 나머지 그룹의 방에서 이미 시도했다면 스킵
            if nextTime >= times[nextRoom][roomMod]:
                continue

            # 복도를 건널 수 있는지 확인
            floorNumber = floorNumbers[room]
            walkable = (prevMod % floorNumber) == (nextRoom % floorNumber)
            if not walkable:
                continue

            # 건널 수 있으면 큐에 대기
            times[nextRoom][roomMod] = nextTime
            heappush(queue, (nextTime, nextRoom, roomMod))

    return -1

print(getTime(destRoom))
```



## 복잡도

방의 개수를 $N$, 복도의 개수를 $M$ 이라고 하자.



### 시간

어떤 경우에도 보통의 다익스트라 알고리즘보다 더 시간을 소요할 수 없으므로 $O(N + M \log N)$.



### 공간

인접 리스트를 이용한 그래프 표현은 $O(N+M)$ 만큼 차지한다.
우선순위 큐와 최소 시간 테이블은 $O(N)$ 만큼 차지한다.

그러므로 $O(N+M)$.
